//------------------------------------------------------------------------------
// <auto-generated>
//     此代码由工具生成。
//     运行时版本:4.0.30319.18449
//
//     对此文件的更改可能会导致不正确的行为，并且如果
//     重新生成代码，这些更改将会丢失。
// </auto-generated>
//------------------------------------------------------------------------------
using System;
namespace AssemblyCSharp
{
		public class readme
		{
				public readme ()
				{
				}
		}
}


/*
 * unity3d加载外部图片

来源： 浏览数：1428 
责任编辑：3D数媒 时间：2013-01-25 17:53
分享到：
[导读]

 最近因为需求加载unity外部图片，所以就小研究了下，下面是自己尝试的集中方法，包括发布***、web、以及Flash三个平台的测试（皆是通过读取XML配置文件加载）：

第一种方法：通过Resources.Load()加载

       这个方法是unity内部提供的一个动态加载的方法，但是经过测试发现，放入unity内部Resources文件下的所有图片发布出来之后都是经过编译的，也就是说我没法在发布出来的文件进行随意的更改我想要显示的图片，这样通过XML配置文件读取就没有任何意思了，所以自己放弃了这种方法。

第二种方法：通过WWW类加载

    这个类也是unity3d内部提供的加载,通过这个类的调用，我们一方面是可以加载本地的图片，一方面也可以加载网络上的图片，所以这为我们做图片的动态加载提供了很好的解决方案，方法如下：

  这个是我的XML配置文件：

  <config>
 <photos icon = "Smallsmall_1" original = "Originaloriginal_1" ></photos>
 <photos icon = "Smallsmall_2" original = "Originaloriginal_2" ></photos>
 <photos icon = "Smallsmall_3" original = "Originaloriginal_3" ></photos>
 <photos icon = "Smallsmall_4" original = "Originaloriginal_4" ></photos>
 <photos icon = "Smallsmall_5" original = "Originaloriginal_5" ></photos>
 <photos icon = "Smallsmall_6" original = "Originaloriginal_6" ></photos>
 <photos icon = "Smallsmall_7" original = "Originaloriginal_7" ></photos>
 <photos icon = "Smallsmall_8" original = "Originaloriginal_8" ></photos>
</config>

一下是我读取的代码

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Xml;
using System.Text;

public class ThurmilUI3 : MonoBehaviour {

           private Texture[] icon;
           private Texture[] originalPhoto;
           private string xmlPath = @"/config.xml";
           private string photoPath = @"/photos/";
           private string iconPath = @"/photos/";
           private string tempPath = "";
           private WWW www;
           IEnumerator Start()
           {
                 xmlPath = Application.dataPath .."+ xmlPath;
                 photoPath ="file://"+ Application.dataPath + @"/.."+ photoPath;
                 iconPath ="file://"+ Application.dataPath + @"/.."+iconPath;
                 if(File.Exists(xmlPath))
                 {
                         XmlDocument xmlDoc = new XmlDocument();
                         xmlDoc.Load(xmlPath);
                         XmlNodeList nodeList = xmlDoc.SelectSingleNode("config").ChildNodes;
                         PrcNum = nodeList.Count;
                         icon = new Texture[PrcNum];
                         originalPhoto = new Texture[PrcNum];
                         int j = 0;
                        foreach(XmlElement xe in nodeList)
                       {
                            Debug.Log("index of image: "+j);
                            tempPath = iconPath + xe.GetAttribute("icon")+".jpg";
                             debugMes = tempPath;
                             www = new WWW(tempPath);
                             yield return www;
                            if()
                           {
                                  icon[j] =www.texture;
                                  if(icon[j] != null)
                                      Debug.Log("Load "+tempPath+" success");
                                 else
                                      Debug.Log("Not Found "+tempPath); 
                           }
                           tempPath = photoPath + xe.GetAttribute("original")+".jpg";
                           www = new WWW(tempPath);
                          yield return www;
                           if()
                           {
                                 originalPhoto[j]=www.texture;
                                if(originalPhoto[j]!= null)
                                       Debug.Log("Load "+tempPath+" success");
                                else
                                       Debug.Log("Not Found "+tempPath);
                         }
                          j++;
    
             }
       }
     else
    {
           debugMes = "xmlPath is not found";
           Debug.LogError("xmlPath is not found");
           return false;
     }
  
   }

void Update()

{

        //在这里我们就可以做我的自己想做的事了

}
}

第三种方法:通过引入System.Drawing的Image类加载显示图片：

方法基本跟上面一样，就说下核心部分：

首先我们可以通过Image image = Image.FromFile(ImagePath);来加载一个图片

或者是通过    FileStream fs = new FileStream(tempPath,FileMode.Open,FileAccess.Read);

      Image image = Image.FromStream(fs);来加载图片

以上方法加载的图片都是一个Image类的属性，跟我们unity3d中使用的Texture2D没法联系上，经过

自己的思考，首先我们可以通过把image加载进来的图片数据信息提取出来，然后再通过Texture2D.LoadImage(byte[] bytes);

来转换到我们再unity中可以使用的Texture2D类，

所以我们首先要编写个获取image图片数据的方法：

 

public byte[] imageToByteArray(System.Drawing.Image imageIn) 

{ 

MemoryStream ms = new MemoryStream(); 

imageIn.Save(ms,System.Drawing.Imaging.ImageFormat.Png); 

return ms.ToArray(); 

}

通过本方法我们就可以应用获取到图片的信息了，剩下的大家都知道怎么做了。


1, Resources 资源目录名,一个字母都不能少,
2, 加载的时候去掉扩展名


 */

